(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{506:function(e,t,a){"use strict";a.r(t);var s=a(48),v=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"差异"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#差异"}},[e._v("#")]),e._v(" 差异")]),e._v(" "),a("p",[e._v("Vue 3的组合式API和React的hook在概念上是相似的，它们都是用于在函数组件中组织和重用逻辑的工具。虽然在实现和使用上有一些细微的差别，但它们的目标和效果是相似的：提供一种更灵活、可组合和可维护的方式来编写组件逻辑")]),e._v(" "),a("h3",{attrs:{id:"语法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#语法"}},[e._v("#")]),e._v(" 语法")]),e._v(" "),a("p",[e._v("Vue 3使用 setup() 函数来定义组件的hook，而React使用 useState() 、 useEffect() 等钩子函数来定义组件的hook。")]),e._v(" "),a("h3",{attrs:{id:"响应式系统"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#响应式系统"}},[e._v("#")]),e._v(" 响应式系统")]),e._v(" "),a("p",[e._v("Vue 3的响应式系统是基于Proxy实现的，可以追踪数据的变化并自动更新相关的视图。而React的hook并没有内置的响应式系统，需要使用 useState() 和 useEffect() 等钩子函数来手动管理状态和副作用。")]),e._v(" "),a("h3",{attrs:{id:"生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期"}},[e._v("#")]),e._v(" 生命周期")]),e._v(" "),a("p",[e._v("Vue3 的 hook 可以在组件的生命周期钩子函数之外使用，而 React 的 hook 只能在函数组件内部使用。")]),e._v(" "),a("h3",{attrs:{id:"组件间通信"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#组件间通信"}},[e._v("#")]),e._v(" 组件间通信")]),e._v(" "),a("p",[e._v("Vue3的hook可以通过 provide 和 inject 来实现组件间的通信，而 React 的 hook 则需要使用上下文（Context）来进行组件间的数据传递。")]),e._v(" "),a("p",[e._v("总的来说，Vue3 的 hook 更加直观和简单，而 React 的 hook 则更加灵活和可扩展。具体选择哪个取决于个人偏好和项目需求。")]),e._v(" "),a("h2",{attrs:{id:"vue3-组合式-api-v3-3"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue3-组合式-api-v3-3"}},[e._v("#")]),e._v(" Vue3 组合式 Api（v3.3+）")]),e._v(" "),a("h3",{attrs:{id:"setup"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#setup"}},[e._v("#")]),e._v(" setup()")]),e._v(" "),a("p",[a("strong",[e._v("基本使用")])]),e._v(" "),a("ul",[a("li",[e._v("需要在非单文件组件中使用组合式 API 时。")]),e._v(" "),a("li",[e._v("需要在基于选项式 API 的组件中集成基于组合式 API 的代码时。")])]),e._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("export")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("default")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("setup")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("props"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" context")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("...")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("p",[e._v("context 是非响应式的，可以安全地解构：")]),e._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("export")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("default")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("setup")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("props"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" attrs"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" slots"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" emit"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" expose "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("...")]),e._v("\n  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])]),e._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[e._v("1")]),a("br"),a("span",{staticClass:"line-number"},[e._v("2")]),a("br"),a("span",{staticClass:"line-number"},[e._v("3")]),a("br"),a("span",{staticClass:"line-number"},[e._v("4")]),a("br"),a("span",{staticClass:"line-number"},[e._v("5")]),a("br")])]),a("h3",{attrs:{id:"响应式-核心"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#响应式-核心"}},[e._v("#")]),e._v(" 响应式：核心")]),e._v(" "),a("ul",[a("li",[e._v("ref()：接受一个内部值，返回一个响应式的、可更改的 ref 对象，此对象只有一个指向其内部值的属性 "),a("code",[e._v(".value")]),e._v("。")]),e._v(" "),a("li",[e._v("computed()：接受一个 getter 函数，返回一个只读的响应式 ref 对象。")]),e._v(" "),a("li",[e._v("reactive()：返回一个对象的响应式代理。")]),e._v(" "),a("li",[e._v("readonly()：接受一个对象 (不论是响应式还是普通的) 或是一个 ref，返回一个原值的只读代理。")]),e._v(" "),a("li",[e._v("watchEffect()：立即运行一个函数，同时响应式地追踪其依赖，并在依赖更改时重新执行。")]),e._v(" "),a("li",[e._v("watchPostEffect()：watchEffect() 使用 "),a("code",[e._v("flush: 'post'")]),e._v(" 选项时的别名。")]),e._v(" "),a("li",[e._v("watchSyncEffect()：watchEffect() 使用 "),a("code",[e._v("flush: 'sync'")]),e._v(" 选项时的别名。")]),e._v(" "),a("li",[e._v("watch()：侦听一个或多个响应式数据源，并在数据源变化时调用所给的回调函数。")])]),e._v(" "),a("h3",{attrs:{id:"响应式-工具"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#响应式-工具"}},[e._v("#")]),e._v(" 响应式：工具")]),e._v(" "),a("ul",[a("li",[e._v("isRef()：检查某个值是否为 ref。")]),e._v(" "),a("li",[e._v("unref()：如果参数是 ref，则返回内部值，否则返回参数本身。这是 "),a("code",[e._v("val = isRef(val) ? val.value : val")]),e._v(" 计算的一个语法糖。")]),e._v(" "),a("li",[e._v("toRef()：可以将值、refs 或 getters 规范化为 refs，也可以基于响应式对象上的一个属性，创建一个对应的 ref。")]),e._v(" "),a("li",[e._v("toValue()：将值、refs 或 getters 规范化为值。这与 unref() 类似，不同的是此函数也会规范化 getter 函数。如果参数是一个 getter，它将会被调用并且返回它的返回值。")]),e._v(" "),a("li",[e._v("toRefs()：将一个响应式对象转换为一个普通对象，这个普通对象的每个属性都是指向源对象相应属性的 ref。每个单独的 ref 都是使用 toRef() 创建的。")]),e._v(" "),a("li",[e._v("isProxy()：检查一个对象是否是由 "),a("code",[e._v("reactive()")]),e._v("、"),a("code",[e._v("readonly()")]),e._v("、"),a("code",[e._v("shallowReactive(")]),e._v(") 或 "),a("code",[e._v("shallowReadonly()")]),e._v(" 创建的代理。")]),e._v(" "),a("li",[e._v("isReactive()：检查一个对象是否是由 reactive() 或 shallowReactive() 创建的代理。")]),e._v(" "),a("li",[e._v("isReadonly()：检查传入的值是否为只读对象。只读对象的属性可以更改，但他们不能通过传入的对象直接赋值。")])]),e._v(" "),a("h3",{attrs:{id:"响应式-进阶"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#响应式-进阶"}},[e._v("#")]),e._v(" 响应式：进阶")]),e._v(" "),a("ul",[a("li",[e._v("shallowRef()：ref() 的浅层作用形式。（不会被深层递归地转为响应式。只有对 .value 的访问是响应式的。）")]),e._v(" "),a("li",[e._v("triggerRef()：强制触发依赖于一个浅层 ref 的副作用，这通常在对浅引用的内部值进行深度变更后使用。")]),e._v(" "),a("li",[e._v("customRef()：创建一个自定义的 ref，显式声明对其依赖追踪和更新触发的控制方式。")]),e._v(" "),a("li",[e._v("shallowReactive()：reactive() 的浅层作用形式。")]),e._v(" "),a("li",[e._v("shallowReadonly()：readonly() 的浅层作用形式")]),e._v(" "),a("li",[e._v("toRaw()：根据一个 Vue 创建的代理返回其原始对象。")]),e._v(" "),a("li",[e._v("markRaw()：将一个对象标记为不可被转为代理。返回该对象本身。")]),e._v(" "),a("li",[e._v("effectScope()：创建一个 effect 作用域，可以捕获其中所创建的响应式副作用 (即计算属性和侦听器)，这样捕获到的副作用可以一起处理。")]),e._v(" "),a("li",[e._v("getCurrentScope()：如果有的话，返回当前活跃的 effect 作用域。")]),e._v(" "),a("li",[e._v("onScopeDispose()：在当前活跃的 effect 作用域上注册一个处理回调函数。当相关的 effect 作用域停止时会调用这个回调函数。")])]),e._v(" "),a("h3",{attrs:{id:"生命周期钩子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#生命周期钩子"}},[e._v("#")]),e._v(" 生命周期钩子")]),e._v(" "),a("ul",[a("li",[e._v("onMounted()：注册一个回调函数，在组件挂载完成后执行。")]),e._v(" "),a("li",[e._v("onUpdated()：注册一个回调函数，在组件因为响应式状态变更而更新其 DOM 树之后调用。")]),e._v(" "),a("li",[e._v("onUnmounted()：注册一个回调函数，在组件实例被卸载之后调用。")]),e._v(" "),a("li",[e._v("onBeforeMount()：注册一个钩子，在组件被挂载之前被调用。")]),e._v(" "),a("li",[e._v("onBeforeUpdate()：注册一个钩子，在组件即将因为响应式状态变更而更新其 DOM 树之前调用。")]),e._v(" "),a("li",[e._v("onBeforeUnmount()：注册一个钩子，在组件实例被卸载之前调用。")]),e._v(" "),a("li",[e._v("onErrorCaptured()：注册一个钩子，在捕获了后代组件传递的错误时调用。")]),e._v(" "),a("li",[e._v("onRenderTracked()：（dev 环境下才有效）")]),e._v(" "),a("li",[e._v("onRenderTriggered()：（dev 环境下才有效）")]),e._v(" "),a("li",[e._v("onActivated()：注册一个回调函数，若组件实例是 "),a("code",[e._v("<KeepAlive>")]),e._v(" 缓存树的一部分，当组件被插入到 DOM 中时调用。（服务端渲染无效）")]),e._v(" "),a("li",[e._v("onDeactivated()：注册一个回调函数，若组件实例是 "),a("code",[e._v("<KeepAlive>")]),e._v(" 缓存树的一部分，当组件从 DOM 中被移除时调用。（服务端渲染无效）")]),e._v(" "),a("li",[e._v("onServerPrefetch()：（ssr 才有效）")])]),e._v(" "),a("h2",{attrs:{id:"react-hook-v18-2-0"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-hook-v18-2-0"}},[e._v("#")]),e._v(" React hook（v18.2.0）")]),e._v(" "),a("ul",[a("li",[e._v("use()：可以让你读取类似于 Promise 或 context 的资源的值。")]),e._v(" "),a("li",[e._v("useCallback()：允许你在多次渲染中缓存函数的 React Hook。")]),e._v(" "),a("li",[e._v("useContext()：可以让你读取和订阅组件中的 context。")]),e._v(" "),a("li",[e._v("useDebugValue()：可以让你在 React 开发工具 中为自定义 Hook 添加标签。")]),e._v(" "),a("li",[e._v("useDeferredValue()：可以让你延迟更新 UI 的某些部分。")]),e._v(" "),a("li",[e._v("useEffect()：允许你 将组件与外部系统同步。")]),e._v(" "),a("li",[e._v("useId()：可以生成传递给无障碍属性的唯一 ID。")]),e._v(" "),a("li",[e._v("useImperativeHandle()：能让你自定义由 ref 暴露出来的句柄。")]),e._v(" "),a("li",[e._v("useMemo()：它在每次重新渲染的时候能够缓存计算的结果。")]),e._v(" "),a("li",[e._v("useReducer()：它允许你向组件里面添加一个 reducer。")]),e._v(" "),a("li",[e._v("useRef()：它能让你引用一个不需要渲染的值。")]),e._v(" "),a("li",[e._v("useState()：它允许你向组件添加一个 状态变量。")]),e._v(" "),a("li",[e._v("useSyncExternalStore()：让你订阅外部 store 的 React Hook。")]),e._v(" "),a("li",[e._v("useTransition()：帮助你在不阻塞 UI 的情况下更新状态的 React Hook。")])])])}),[],!1,null,null,null);t.default=v.exports}}]);