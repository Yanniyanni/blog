(window.webpackJsonp=window.webpackJsonp||[]).push([[79],{484:function(t,n,e){"use strict";e.r(n);var o=e(48),a=Object(o.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("ppt： https://m.taoke.com/front_new/pxb/webapp/html/student/student.html#/elearning/detail/attach?course_id=5076183&company_id=1459182&f=index&breakthrough_id=&breakthrough_project_id=&backType=")]),t._v(" "),e("p",[t._v("https://zhuanlan.zhihu.com/p/78362028")]),t._v(" "),e("p",[t._v("微前端要解决的问题")]),t._v(" "),e("ul",[e("li",[t._v("主应用如何更新子应用资源")]),t._v(" "),e("li",[t._v("子应用的js和样式隔离")]),t._v(" "),e("li",[t._v("技术栈无关，只是通过")])]),t._v(" "),e("p",[t._v("隔离：应用隔离、样式隔离、js隔离")]),t._v(" "),e("p",[t._v("可以把应用生命周期拉长了看，比如一个开发了三年的应用...就算都是react都是antd也是有版本差异breaking chang之类的，传统方式的话要么一把梭升级全量回归(基本不被允许)要么锁死到某一个版本的技术栈")]),t._v(" "),e("p",[t._v("问题：\n主项目如何跟子项目通信\n在js隔离方案中，如果子应用在mount之后修改了全局状态，子应用remount的时候取上一次mount前的全局快照，那么修改是不是丢失了呢\n子应用与子应用之间隔离了，主应用与子应用怎么做隔离\n生产环境主项目和子项目之间的跨域问题如何解决呢？\nqiankun怎么处理子应用之间的逻辑复用呢，例如有store要被两个子应用去使用。是通过父应用来传递？还是把这部分抽离成单独的包让子应用项目分部import？另外公共部分最终是通过window来挂载吗？\n主应用怎么通知子应用的接口重新请求。")])])}),[],!1,null,null,null);n.default=a.exports}}]);