(window.webpackJsonp=window.webpackJsonp||[]).push([[192],{593:function(t,a,s){"use strict";s.r(a);var r=s(48),_=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"_1、介绍下-bfc、ifc、gfc-和-ffc-及其应用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、介绍下-bfc、ifc、gfc-和-ffc-及其应用"}},[t._v("#")]),t._v(" 1、介绍下 BFC、IFC、GFC 和 FFC 及其应用")]),t._v(" "),s("blockquote",[s("p",[t._v("Formatting Contexts：格式化上下文，指页面中一个渲染区域，拥有一套渲染规则，它决定了其子元素如何定位，以及与其他元素的相互关系和作用。")])]),t._v(" "),s("p",[t._v("其实就是通过设置不同的displa值，让那个区域按照不同的规则渲染：")]),t._v(" "),s("ul",[s("li",[t._v("BFC：块级格式化上下文 =》  盒子垂直放置, 垂直间距决定于最大的margin属性 =》 display: inline-block;")]),t._v(" "),s("li",[t._v("IFC: 内联格式化上下文 =》 盒子水平放置，水平方向不会发生margin重叠，但垂直方向margin、padding无效 =》 display: inline;")]),t._v(" "),s("li",[t._v("GFC: 网格布局格式化上下文 =》 网格布局 =》 display: grid;")]),t._v(" "),s("li",[t._v("FFC: 自适应格式化上下文 =》 flex 布局 =》 display: flex/inline-flex;")])]),t._v(" "),s("p",[s("RouterLink",{attrs:{to:"/frontend/css/layout.html#bfc与ifc"}},[t._v("《参考》")])],1),t._v(" "),s("h3",{attrs:{id:"_2、css-重绘和重排有什么区别-哪些css属性会导致重绘和重排"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、css-重绘和重排有什么区别-哪些css属性会导致重绘和重排"}},[t._v("#")]),t._v(" 2、css 重绘和重排有什么区别？哪些css属性会导致重绘和重排？")]),t._v(" "),s("blockquote",[s("p",[t._v("涉及到浏览器渲染")])]),t._v(" "),s("p",[t._v("重绘是当元素外观改变时引起浏览器重新绘制，重排是当元素几何信息和位置改变时引起的重新排版。")]),t._v(" "),s("p",[t._v("引起重绘的属性：color、background、box-shadow等")]),t._v(" "),s("p",[t._v("引起重排的属性：width、height、position、float等")]),t._v(" "),s("p",[t._v("损耗：重排（layout） > 重绘（paint）")]),t._v(" "),s("p",[t._v("解决：避免一次次改，最好批量改，动画最好做定位，不要影响整体布局，引发重排等。")]),t._v(" "),s("p",[s("RouterLink",{attrs:{to:"/frontend/browser/render.html#重绘和重排"}},[t._v("《参考》")])],1),t._v(" "),s("h3",{attrs:{id:"_3、rem-和-flex-的区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、rem-和-flex-的区别"}},[t._v("#")]),t._v(" 3、rem 和 flex 的区别？")]),t._v(" "),s("p",[t._v("rem 是相对单位，flex 是 css3 新增的一种弹性布局。他们主要解决不同屏幕尺寸适配问题。")]),t._v(" "),s("p",[t._v("rem 需要设置 viewport 和 body 的font-size，默认是跟 16px 做对比")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v('<meta name="viewport" content="initial-scale=1,maximum-scale=1, minimum-scale=1">\n')])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[s("RouterLink",{attrs:{to:"/frontend/css/units.html#移动端适配方案"}},[t._v("《参考》")])],1),t._v(" "),s("h3",{attrs:{id:"_4、css-的解析顺序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4、css-的解析顺序"}},[t._v("#")]),t._v(" 4、css 的解析顺序？")]),t._v(" "),s("p",[s("RouterLink",{attrs:{to:"/frontend/css/selector.html"}},[t._v("《参考》")])],1),t._v(" "),s("h3",{attrs:{id:"_5、css-如何开启-gpu-加速"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5、css-如何开启-gpu-加速"}},[t._v("#")]),t._v(" 5、css 如何开启 gpu 加速？")]),t._v(" "),s("p",[t._v("在动画的时候使用 transform 开启加速")]),t._v(" "),s("p",[s("RouterLink",{attrs:{to:"/frontend/css/animation.html#动画性能分析和浏览器gpu加速"}},[t._v("《参考》")])],1),t._v(" "),s("h3",{attrs:{id:"_6、分析比较-opacity-0-visible-hidden-display-none-优劣和使用场景。"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_6、分析比较-opacity-0-visible-hidden-display-none-优劣和使用场景。"}},[t._v("#")]),t._v(" 6、分析比较 opacity: 0; visible: hidden; display: none; 优劣和使用场景。")]),t._v(" "),s("p",[s("RouterLink",{attrs:{to:"/frontend/css/attribute.html#隐藏页面元素的方法"}},[t._v("《参考》")])],1),t._v(" "),s("h3",{attrs:{id:"_7、-before和-after中单冒号和双冒号的区别是什么-这两个伪元素有什么作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_7、-before和-after中单冒号和双冒号的区别是什么-这两个伪元素有什么作用"}},[t._v("#")]),t._v(" 7、::before和:after中单冒号和双冒号的区别是什么，这两个伪元素有什么作用？")]),t._v(" "),s("p",[t._v("单冒号是伪类，双冒号是伪元素。为了兼容，部分伪元素支持单冒号，如 :before 和 :after。")]),t._v(" "),s("p",[t._v("::before: 在某元素前插入内容, ::after: 在某元素后插入内容。")]),t._v(" "),s("p",[t._v("常用场景：标题前 加 icon")]),t._v(" "),s("p",[s("RouterLink",{attrs:{to:"/frontend/css/selector.html#伪类和伪元素"}},[t._v("《参考》")])],1),t._v(" "),s("h3",{attrs:{id:"_8、请描述-margin-边界叠加是什么及解决方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8、请描述-margin-边界叠加是什么及解决方案"}},[t._v("#")]),t._v(" 8、请描述 margin 边界叠加是什么及解决方案")]),t._v(" "),s("blockquote",[s("p",[t._v("另一种问法：margin 坍塌是什么？怎么解决？")])]),t._v(" "),s("p",[t._v("原因：在 BFC 中,两个相邻块级盒子之间垂直方向上的外边距是会塌陷/叠加")]),t._v(" "),s("p",[t._v("一般需要解决的是父子元素的 margin 叠加。解决方法：")]),t._v(" "),s("ul",[s("li",[t._v("父 Div 设置 overflow:hidden;")]),t._v(" "),s("li",[t._v("父 Div 设置 padding: 1px;")]),t._v(" "),s("li",[t._v("父 Div 设置 border: 1px solid transparent;")]),t._v(" "),s("li",[t._v("父 Div 设置 position: absolute;")]),t._v(" "),s("li",[t._v("子 Div 设置 float:left;")]),t._v(" "),s("li",[t._v("子 Div 设置 display: inline-block;")])]),t._v(" "),s("h3",{attrs:{id:"_9、什么是fouc-你是如何避免fouc的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_9、什么是fouc-你是如何避免fouc的"}},[t._v("#")]),t._v(" 9、什么是FOUC？你是如何避免FOUC的？")]),t._v(" "),s("p",[t._v("FOUC: Flash of Unstyled Content（文档样式短暂失效），这种现象也称为浏览器样式闪烁。")]),t._v(" "),s("p",[s("strong",[t._v("原因可能为：")])]),t._v(" "),s("ol",[s("li",[t._v("使用import方法导入样式表")]),t._v(" "),s("li",[t._v("将样式表放在页面底部")]),t._v(" "),s("li",[t._v("有几个样式表，放在html结构的不同位置")])]),t._v(" "),s("p",[s("strong",[t._v("原理：")])]),t._v(" "),s("p",[t._v("当样式表晚于结构性html 加载，当加载到此样式表时，页面将停止之前的渲染。 此样式表被下载和解析后，将重新渲染页面，也就出现了短暂的花屏现象。")]),t._v(" "),s("p",[s("strong",[t._v("解决方法：")])]),t._v(" "),s("p",[t._v("使用link标签将样式表放在文档head中")]),t._v(" "),s("h3",{attrs:{id:"_10、说说-css-优先级"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_10、说说-css-优先级"}},[t._v("#")]),t._v(" 10、说说 css 优先级")]),t._v(" "),s("p",[s("code",[t._v("!important > 内联样式 > id选择器 > class 选择器 > 标签(h1)")])]),t._v(" "),s("p",[s("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/CSS/Specificity",target:"_blank",rel:"noopener noreferrer"}},[t._v("《参考》"),s("OutboundLink")],1)]),t._v(" "),s("h3",{attrs:{id:"_11、rgba-和opacity这两个的透明效果有什么区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_11、rgba-和opacity这两个的透明效果有什么区别"}},[t._v("#")]),t._v(" 11、rgba()和opacity这两个的透明效果有什么区别？")]),t._v(" "),s("p",[t._v("opacity 作用于元素，以及元素内的所有内容的透明度，包括子元素。")]),t._v(" "),s("p",[t._v("rgba() 只作用于元素的颜色或其背景色，并且设置 rgba 透明的元素的子元素不会继承透明效果！")]),t._v(" "),s("p",[s("RouterLink",{attrs:{to:"/frontend/css/render.html#颜色"}},[t._v("《参考》")])],1),t._v(" "),s("h3",{attrs:{id:"_12、当一个元素被设置为浮动或定位后-它的display值会变成什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_12、当一个元素被设置为浮动或定位后-它的display值会变成什么"}},[t._v("#")]),t._v(" 12、当一个元素被设置为浮动或定位后，它的display值会变成什么？")]),t._v(" "),s("p",[t._v("无论元素之前display属性是inline、inline-block、block或者其他什么，都会变成 block。")]),t._v(" "),s("p",[t._v("所以如果行内元素设置浮动后就可以设置宽高了。")]),t._v(" "),s("h3",{attrs:{id:"_13、对-flex-布局的了解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13、对-flex-布局的了解"}},[t._v("#")]),t._v(" 13、对 flex 布局的了解")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://www.runoob.com/w3cnote/flex-grammar.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("《Flex 布局》"),s("OutboundLink")],1)]),t._v(" "),s("h3",{attrs:{id:"_14、介绍移动端适配1px方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14、介绍移动端适配1px方案"}},[t._v("#")]),t._v(" 14、介绍移动端适配1px方案")]),t._v(" "),s("p",[t._v("移动端 1px 原因：retina 高清屏 的 dpr，1px = 2px")]),t._v(" "),s("p",[t._v("解决：")]),t._v(" "),s("ol",[s("li",[t._v("svg =》 设置 background-image")]),t._v(" "),s("li",[t._v("伪元素 before/after =》 transform: scale(0.5)")])]),t._v(" "),s("h3",{attrs:{id:"_15、介绍下position属性-position-sticky是什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_15、介绍下position属性-position-sticky是什么"}},[t._v("#")]),t._v(" 15、介绍下position属性，position: sticky是什么")]),t._v(" "),s("p",[t._v("position 属性可以设置元素的定位。它有 fixed 、 absolute 、 relative 、 static（默认值）、 inherit 、sticky（css3新增）可选。")]),t._v(" "),s("ul",[s("li",[t._v("static： 是默认值，代表没有定位，处于正常文档流")]),t._v(" "),s("li",[t._v("inherit： 表示继承父元素 position 属性，但 IE8 前不兼容")]),t._v(" "),s("li",[t._v("sticky：粘性定位，当滚动元素距离父元素达到 sticky 设置的要求时(如top: 100px)，此时出现 fixed 效果。但有兼容性问题。")])]),t._v(" "),s("p",[t._v("sticky 可以用于设置吸顶效果。")]),t._v(" "),s("h3",{attrs:{id:"_16-介绍下都有什么盒子模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_16-介绍下都有什么盒子模型"}},[t._v("#")]),t._v(" 16. 介绍下都有什么盒子模型")]),t._v(" "),s("p",[t._v("盒子模型（Box Model）就是把HTML页面中的元素看作是一个矩形的盒子，也就是一个盛装内容的容器。每个矩形都由元素的内容(content)、内边距（padding）、边框（border）和外边距（margin）组成。")]),t._v(" "),s("p",[t._v("盒子模型有两种：")]),t._v(" "),s("ul",[s("li",[t._v("w3c 标准盒子模型。盒子的宽高"),s("strong",[t._v("不包含padding和border")]),t._v("。可通过设置"),s("code",[t._v("box-sizing:content-box;")]),t._v("转换为标准模式")]),t._v(" "),s("li",[t._v("IE 怪异盒子模型。盒子的宽高"),s("strong",[t._v("包含了padding和border")]),t._v("。可通过设置"),s("code",[t._v("box-sizing:border-box;")]),t._v("转换为怪异模式")])])])}),[],!1,null,null,null);a.default=_.exports}}]);