(window.webpackJsonp=window.webpackJsonp||[]).push([[204],{606:function(t,e,v){"use strict";v.r(e);var a=v(48),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h3",{attrs:{id:"_1-v-if-和-v-show-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-v-if-和-v-show-的区别"}},[t._v("#")]),t._v(" 1. v-if 和 v-show 的区别")]),t._v(" "),v("p",[t._v('v-if 会控制dom是否渲染，如果是false的话会将整个dom移除。v-show 是类似于给标签添加了一个style="display:none",在初始化的时候都会加载。')]),t._v(" "),v("p",[t._v("v-if 比 v-show 损耗性能。")]),t._v(" "),v("p",[t._v("使用场景：当频繁切换的时候，可以使用v-show。")]),t._v(" "),v("h3",{attrs:{id:"_2-v-for-为什么要加上-key-有什么作用-v-for-为什么不能跟-v-if-一起使用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-v-for-为什么要加上-key-有什么作用-v-for-为什么不能跟-v-if-一起使用"}},[t._v("#")]),t._v(" 2. v-for 为什么要加上 key，有什么作用？v-for 为什么不能跟 v-if 一起使用")]),t._v(" "),v("p",[t._v("v-for 可以循环数组，也可以循环对象。key 是作为唯一性，让 vue 在进行 diff 算法的时候更准确的识别。")]),t._v(" "),v("p",[t._v("v-for 的优先级比 v-if 高，每次列表渲染都会进行一次判断，如果列表数据很多的话，性能损耗严重。")]),t._v(" "),v("blockquote",[v("p",[t._v("3.0版本中。v-if 的优先级高于 v-for")])]),t._v(" "),v("h3",{attrs:{id:"_3-v-if、v-show、v-html-的原理是什么-它是如何封装的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-v-if、v-show、v-html-的原理是什么-它是如何封装的"}},[t._v("#")]),t._v(" 3. v-if、v-show、v-html 的原理是什么，它是如何封装的")]),t._v(" "),v("p",[t._v("v-if 会调用 addIfCondition 方法，生成 vnode 的时候会忽略对应节点，render 的时候就不会渲染；")]),t._v(" "),v("p",[t._v("v-show 会生成 vnode，render 的时候也会渲染成真实节点，只是在 render 过程中会在节点的属性中修改 show 属性值，也就是常说的 display；")]),t._v(" "),v("p",[t._v("v-html 会先移除节点下的所有节点，调用 html 方法，通过 addProp 添加innerHTML属性，归根结底还是设置innerHTML为v-html的值。")]),t._v(" "),v("h3",{attrs:{id:"_4-computed-是如何实现的-它和-watch-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-computed-是如何实现的-它和-watch-的区别"}},[t._v("#")]),t._v(" 4. computed 是如何实现的？它和 watch 的区别")]),t._v(" "),v("p",[t._v("computed 会搜集并记录依赖。")]),t._v(" "),v("p",[t._v("初始化 =》 initComputed - 给每个属性添加watcher 并且执行 definedComputed =》 definedComputed - createComputedGetter =》createComputedGetter =》判断是否 dirty")]),t._v(" "),v("p",[t._v("computed 是计算属性，watch 是监听属性，两者功能不一样。computed 有缓存，如果data值不改变，则不会重新计算，这样能提高性能。")]),t._v(" "),v("p",[t._v("watch 可以监听数据变化，对于引用类型，可以配置"),v("code",[t._v("deep: true")]),t._v("进行深度监听，但引用类型是拿不到oldVal的值的，因为指向都是同一个内存对象。")]),t._v(" "),v("p",[v("a",{attrs:{href:"https://www.jianshu.com/p/b38f826f42bc",target:"_blank",rel:"noopener noreferrer"}},[t._v("《computed 原理解析》"),v("OutboundLink")],1)]),t._v(" "),v("h3",{attrs:{id:"_5-介绍下-vue-的事件-它是挂载在哪里的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-介绍下-vue-的事件-它是挂载在哪里的"}},[t._v("#")]),t._v(" 5. 介绍下 vue 的事件，它是挂载在哪里的？")]),t._v(" "),v("p",[t._v("vue 的事件通过 "),v("code",[t._v("@")]),t._v(" 关键字，默认会传一个 event，这个 event 是原生的 event 对象，通过event.currentTarget知道，事件是绑定在当前元素上的。")]),t._v(" "),v("p",[t._v("react 的事件是合成事件。")]),t._v(" "),v("h3",{attrs:{id:"_6-vue-在-v-for-时给每项元素绑定事件需要用事件代理吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-vue-在-v-for-时给每项元素绑定事件需要用事件代理吗"}},[t._v("#")]),t._v(" 6. vue 在 v-for 时给每项元素绑定事件需要用事件代理吗")]),t._v(" "),v("p",[t._v("事件代理 == 事件委托：利用事件冒泡，只制定一个处理程序，就可以管理某一类型的所有事件。如点击事件绑定到列表的外层元素上。")]),t._v(" "),v("p",[t._v("vue 的 v-for 循环是没有做事件代理的，如果有需要要自己手动代理。")]),t._v(" "),v("p",[v("RouterLink",{attrs:{to:"/frontend/javascript/event.html#事件委托-事件代理"}},[t._v("《参考》")])],1),t._v(" "),v("h3",{attrs:{id:"_7-父子组件生命周期钩子执行顺序是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-父子组件生命周期钩子执行顺序是什么"}},[t._v("#")]),t._v(" 7. 父子组件生命周期钩子执行顺序是什么")]),t._v(" "),v("blockquote",[v("p",[t._v("从生命周期过程来看，每个组件都需要先解析生成vdom然后再挂载，基于这个顺序，每个子组件都是在父组件内，那么父组件在生成 vdom 的过程势必要先解析子组件，将子组件挂载后，再挂载父组件（爷孙组件也是一样），如果有多个子组件，则按子组件的排列顺序。也就是：")])]),t._v(" "),v("h4",{attrs:{id:"父子生命周期"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#父子生命周期"}},[t._v("#")]),t._v(" 父子生命周期")]),t._v(" "),v("p",[t._v("父 beforeCreate =》 父 created =》 父 beforeMounted =》 子 beforeCreate =》 子 created =》 子 beforeMounted =》 子 mounted =》 父 mounted")]),t._v(" "),v("h4",{attrs:{id:"父子组件通讯"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#父子组件通讯"}},[t._v("#")]),t._v(" 父子组件通讯")]),t._v(" "),v("ol",[v("li",[t._v("通过props 和 $emit，数据是单向的。子组件不能修改 props 值")]),t._v(" "),v("li",[t._v("绑定自定义事件。通过 vue 实例自带的事件方法可以做到。 $emit 触发、 $on 绑定. $off 解除")])]),t._v(" "),v("h4",{attrs:{id:"父子更新顺序"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#父子更新顺序"}},[t._v("#")]),t._v(" 父子更新顺序")]),t._v(" "),v("p",[t._v("父 beforeUpdate =》 子 beforeUpdate =》 子 updated =》 父 updated")]),t._v(" "),v("h3",{attrs:{id:"_8-子组件为什么不可以修改父组件传递的-prop"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-子组件为什么不可以修改父组件传递的-prop"}},[t._v("#")]),t._v(" 8. 子组件为什么不可以修改父组件传递的 prop")]),t._v(" "),v("p",[t._v("props 是单向数据流，父级的 props 更新会向下流动到子组件，但反过来不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。")]),t._v(" "),v("p",[t._v("注意：在子组件内直接修改基本类型的 props 值会直接报错，但如果修改引用类型则不会，因为引用类型传递过去的是一个指针，子组件改变值并没有改变指针，所以不会报错")]),t._v(" "),v("h3",{attrs:{id:"_9-什么是高阶组件-高阶组件和普通组件的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9-什么是高阶组件-高阶组件和普通组件的区别"}},[t._v("#")]),t._v(" 9. 什么是高阶组件？高阶组件和普通组件的区别")]),t._v(" "),v("p",[t._v("所谓高阶组件其实就是高阶函数，一个函数就是一个组件。高阶函数接受一个组件作为参数，返回一个新的组件。")]),t._v(" "),v("div",{staticClass:"language-js line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("export")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("default")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("WithConsole")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("WrappedComponent")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    template"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token string"}},[t._v('\'<wrapped v-on="$listeners" v-bind="$attrs"/>\'')]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    components"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      wrapped"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" WrappedComponent\n    "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n    "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("mounted")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      console"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token string"}},[t._v("'I have already mounted'")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n    "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n  "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br"),v("span",{staticClass:"line-number"},[t._v("5")]),v("br"),v("span",{staticClass:"line-number"},[t._v("6")]),v("br"),v("span",{staticClass:"line-number"},[t._v("7")]),v("br"),v("span",{staticClass:"line-number"},[t._v("8")]),v("br"),v("span",{staticClass:"line-number"},[t._v("9")]),v("br"),v("span",{staticClass:"line-number"},[t._v("10")]),v("br"),v("span",{staticClass:"line-number"},[t._v("11")]),v("br")])]),v("h3",{attrs:{id:"_10-如何自定义一个-v-model"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10-如何自定义一个-v-model"}},[t._v("#")]),t._v(" 10. 如何自定义一个 v-model")]),t._v(" "),v("p",[t._v("一个组件上的 v-model 默认会利用名为 value 的 prop 和名为 input 的事件。但是可以使用 model 属性，指定 props 和 event 设置对应值和事件")]),t._v(" "),v("p",[v("a",{attrs:{href:"https://cn.vuejs.org/v2/guide/components-custom-events.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6%E7%9A%84-v-model",target:"_blank",rel:"noopener noreferrer"}},[t._v("《参考》"),v("OutboundLink")],1)]),t._v(" "),v("h3",{attrs:{id:"_11-谈一谈-nexttick-原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_11-谈一谈-nexttick-原理"}},[t._v("#")]),t._v(" 11. 谈一谈 nextTick 原理")]),t._v(" "),v("p",[t._v("vue 是异步渲染（ dom 改变后不会立刻渲染），当渲染完之后就会触发 nextTick 函数，可以把这个函数看成是vue dom 重新渲染后的回调函数。（所以不是每次数据修改都会触发，vue 会等所有的 data 都修改完之后才会触发）")]),t._v(" "),v("p",[t._v("nextTick 不会每次修改都触发，会等前面所有的data都修改完之后，一次性触发。")]),t._v(" "),v("p",[t._v("使用场景：当需要dom更新完之后再调用的时候")]),t._v(" "),v("h3",{attrs:{id:"_12-什么是动态组件和异步组件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_12-什么是动态组件和异步组件"}},[t._v("#")]),t._v(" 12. 什么是动态组件和异步组件")]),t._v(" "),v("p",[t._v("可能延伸到缓存 - 性能优化方面")]),t._v(" "),v("p",[t._v("动态组件是通过"),v("code",[t._v('<component :is="comName">')]),t._v(" 方式动态生成组件\n使用场景：当组件类型不确定是，需要根据数据动态渲染时可使用")]),t._v(" "),v("p",[t._v("使用 "),v("code",[t._v("<keep-alive>")]),t._v(" 可以缓存组件，通过v-if控制时，组件不会被移除，也不会重新渲染？？\n如果数据需要刷新如何操作？")]),t._v(" "),v("p",[t._v("使用场景：当频繁切换，不需要重复渲染时，如一些后台管理系统一个页面有很多的 tab 标签页")]),t._v(" "),v("h3",{attrs:{id:"_13-什么是-mvvm-mvvm-和-mvc-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_13-什么是-mvvm-mvvm-和-mvc-的区别"}},[t._v("#")]),t._v(" 13. 什么是 MVVM？MVVM 和 MVC 的区别")]),t._v(" "),v("p",[t._v("这两个种是不同的软件设计模式：")]),t._v(" "),v("p",[t._v("MVC：M（model）. V（view）、C（controller）")]),t._v(" "),v("p",[t._v("MVVM：M（model）、V（view）、VM（viewModel）数据驱动视图")]),t._v(" "),v("p",[t._v("区别：")]),t._v(" "),v("h3",{attrs:{id:"_14-vue-中-mvvm-分别代表什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-vue-中-mvvm-分别代表什么"}},[t._v("#")]),t._v(" 14. vue 中 MVVM 分别代表什么")]),t._v(" "),v("p",[t._v("M（model）、V（view）、VM（viewModel）")]),t._v(" "),v("h3",{attrs:{id:"_15-说一下组件化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_15-说一下组件化"}},[t._v("#")]),t._v(" 15. 说一下组件化")]),t._v(" "),v("p",[t._v("开放题。注意有时会过度组件化。")]),t._v(" "),v("p",[t._v("使用js 和 ts 的组件化会不一样。ts 会更加的规范化，无论是在开发者开发还是使用者使用的时候，都能进行提示和报错。不仅仅依赖文档说明。")]),t._v(" "),v("h3",{attrs:{id:"_16-聊聊-vue-的双向数据绑定-model-如何改变-view-view-又是如何改变-model-的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_16-聊聊-vue-的双向数据绑定-model-如何改变-view-view-又是如何改变-model-的"}},[t._v("#")]),t._v(" 16. 聊聊 Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的")]),t._v(" "),v("h3",{attrs:{id:"_17-vue-的响应式原理中-object-defienproperty-有什么缺陷"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_17-vue-的响应式原理中-object-defienproperty-有什么缺陷"}},[t._v("#")]),t._v(" 17. Vue 的响应式原理中 Object.defienProperty 有什么缺陷？")]),t._v(" "),v("ul",[v("li",[t._v("无法监听数组的变化")]),t._v(" "),v("li",[t._v("必须遍历对象的每个属性")]),t._v(" "),v("li",[t._v("必须深层遍历嵌套的对象")]),t._v(" "),v("li",[t._v("无法监听新增属性、删除属性")]),t._v(" "),v("li",[t._v("需要在开始时一次性递归所有属性")])]),t._v(" "),v("p",[v("RouterLink",{attrs:{to:"/framework/frame/vue.html#响应式原理"}},[t._v("参考")])],1),t._v(" "),v("h3",{attrs:{id:"_18-data-中为什么要-return-一个函数"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_18-data-中为什么要-return-一个函数"}},[t._v("#")]),t._v(" 18. data 中为什么要 return 一个函数")]),t._v(" "),v("p",[t._v("为了避免全局污染。return 一个函数相当于为每一个组件都创建了一个data，就不会污染了。")]),t._v(" "),v("h3",{attrs:{id:"_19-visual-dom-真的比原生-dom-操作快吗-谈谈你的想法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_19-visual-dom-真的比原生-dom-操作快吗-谈谈你的想法"}},[t._v("#")]),t._v(" 19. Visual Dom 真的比原生 dom 操作快吗？谈谈你的想法")]),t._v(" "),v("p",[t._v("js 的计算会比操作原生dom要快，因为操作dom不仅要运行js，而且会引起浏览器的重排，重排是非常损耗性能的。")]),t._v(" "),v("p",[v("RouterLink",{attrs:{to:"/frontend/browser/render.html#重绘和重排"}},[t._v("《参考》")])],1),t._v(" "),v("h3",{attrs:{id:"_20-react-和-vue-的-diff-时间复杂度从-o-n-3-优化到-o-n-那么-o-n-3-和-o-n-是如何计算出来的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_20-react-和-vue-的-diff-时间复杂度从-o-n-3-优化到-o-n-那么-o-n-3-和-o-n-是如何计算出来的"}},[t._v("#")]),t._v(" 20. React 和 Vue 的 diff 时间复杂度从 O(n^3) 优化到 O(n) ，那么 O(n^3) 和 O(n) 是如何计算出来的？")]),t._v(" "),v("p",[t._v("diff 算法优化")]),t._v(" "),v("ol",[v("li",[t._v("同级对比")]),t._v(" "),v("li",[t._v("同级如果相同则不做操作，不同移除后替换，不再对比")])]),t._v(" "),v("h3",{attrs:{id:"_21-vue-渲染大量数据时应该怎么优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_21-vue-渲染大量数据时应该怎么优化"}},[t._v("#")]),t._v(" 21. vue 渲染大量数据时应该怎么优化？")]),t._v(" "),v("p",[t._v("不需要响应的数据，可以将数据冻结，让vue不再监听这块数据作为响应。")]),t._v(" "),v("h3",{attrs:{id:"_22-vue-如何优化首页的加载速度-vue-首页白屏是什么问题引起的-如何解决呢"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_22-vue-如何优化首页的加载速度-vue-首页白屏是什么问题引起的-如何解决呢"}},[t._v("#")]),t._v(" 22. vue 如何优化首页的加载速度？vue 首页白屏是什么问题引起的？如何解决呢？")]),t._v(" "),v("h3",{attrs:{id:"_23-vue-是如何对数组方法进行变异的-例如-push、pop、splice-等方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_23-vue-是如何对数组方法进行变异的-例如-push、pop、splice-等方法"}},[t._v("#")]),t._v(" 23. vue 是如何对数组方法进行变异的？例如 push、pop、splice 等方法")]),t._v(" "),v("h3",{attrs:{id:"_24-vue-router-里的-router-link-标签和-a-标签有什么区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_24-vue-router-里的-router-link-标签和-a-标签有什么区别"}},[t._v("#")]),t._v(" 24. vue-router 里的"),v("code",[t._v("<router-link>")]),t._v("标签和"),v("code",[t._v("<a>")]),t._v("标签有什么区别")]),t._v(" "),v("p",[t._v("router-link 进行跳转不会跳转到新的页面，不会重新渲染，它会选择路由所指的组件进行渲染。在history 和 hash模式下表现一致")]),t._v(" "),v("p",[t._v("a标签跳转，页面就会重新加载，相当于打开一个新的页面")]),t._v(" "),v("p",[t._v("如果 router-link 中包含 a 标签，a 标签会取代 router-link 实现跳转")]),t._v(" "),v("h3",{attrs:{id:"_25-路由模式-hash、history-模式的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_25-路由模式-hash、history-模式的区别"}},[t._v("#")]),t._v(" 25. 路由模式：hash、history 模式的区别")]),t._v(" "),v("p",[t._v("路径不同：hash 会带有 “#” 号")]),t._v(" "),v("p",[t._v("实现原理：都是通过监听 url 上的变化，然后对浏览器的访问历史进行操作，只是调用Api有所不同。")]),t._v(" "),v("p",[t._v("vue-router 支持3种模式，默认使用hash模式。如果浏览器不支持 history 模式，则自动使用hash模式。")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("hash模式：调用"),v("code",[t._v("window.locatio.replace()")]),t._v("、"),v("code",[t._v("window.location.href()")]),t._v(" 等api。（hash值得改变是不会刷新页面的）。")])]),t._v(" "),v("li",[v("p",[t._v("history模式：调用 HTML5 的history 有关API。"),v("code",[t._v("window.history.replaceState()")]),t._v("、"),v("code",[t._v("window.history.pushState()")]),t._v("等")])]),t._v(" "),v("li",[v("p",[t._v("abstract模式：非浏览器环境（如在node里使用）")])])]),t._v(" "),v("h3",{attrs:{id:"_26-什么是动态路由-如何实现懒加载"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_26-什么是动态路由-如何实现懒加载"}},[t._v("#")]),t._v(" 26. 什么是动态路由，如何实现懒加载？")]),t._v(" "),v("p",[t._v("动态路由：/user/:id")]),t._v(" "),v("p",[t._v("懒加载："),v("code",[t._v('() => import("../path")')])]),t._v(" "),v("p",[t._v("涉及到webpack打包")]),t._v(" "),v("blockquote",[v("p",[t._v("es6 有个类似的 "),v("RouterLink",{attrs:{to:"/frontend/javascript/module.html#动态import"}},[t._v("动态import")])],1)]),t._v(" "),v("p",[v("strong",[t._v("路由钩子")])]),t._v(" "),v("p",[t._v("使用场景：常在 main 中使用，权限控制，动态路由等")]),t._v(" "),v("h3",{attrs:{id:"_27-为什么-vuex-的-mutation-和-redux-的-reducer-中不能做异步操作"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_27-为什么-vuex-的-mutation-和-redux-的-reducer-中不能做异步操作"}},[t._v("#")]),t._v(" 27. 为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作？")]),t._v(" "),v("p",[t._v("因为 mutation 直接修改 state，如果 mutation 做异步处理，有多个异步操作的情况下，就无法判断哪一个才是最新值，造成数据混乱。")]),t._v(" "),v("blockquote",[v("p",[t._v("延伸问题")])]),t._v(" "),v("ol",[v("li",[t._v("那异步应该写在哪里？（action）")]),t._v(" "),v("li",[t._v("页面刷新数据丢失问题怎么解决（前端存储：cookie、session等）")])]),t._v(" "),v("h3",{attrs:{id:"_28-双向绑定和-vuex-是否冲突"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_28-双向绑定和-vuex-是否冲突"}},[t._v("#")]),t._v(" 28. 双向绑定和 vuex 是否冲突？")]),t._v(" "),v("p",[t._v("不冲突。")]),t._v(" "),v("h3",{attrs:{id:"_29-聊聊-redux-和-vuex-的设计思想"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_29-聊聊-redux-和-vuex-的设计思想"}},[t._v("#")]),t._v(" 29. 聊聊 Redux 和 Vuex 的设计思想")]),t._v(" "),v("p",[t._v("它们提供了一个状态管理库，采用集中式存储管理应用的所有组件的状态。")]),t._v(" "),v("p",[t._v("在vue初始化的时候，会并将数据存放到全局的store，再将store挂载到每个vue实例组件中。")]),t._v(" "),v("p",[t._v("其他组件间共享数据的方法：")]),t._v(" "),v("ul",[v("li",[t._v("父子组件间传值：$emit、props")]),t._v(" "),v("li",[t._v("依赖注入(深层传值)：provide/inject")]),t._v(" "),v("li",[t._v("直接获取组件，进行传值：ref、$parent/$child")])]),t._v(" "),v("h3",{attrs:{id:"_30-如何让基于-vue-js-的应用支持-seo-优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_30-如何让基于-vue-js-的应用支持-seo-优化"}},[t._v("#")]),t._v(" 30. 如何让基于 Vue.js 的应用支持 SEO 优化？")]),t._v(" "),v("ol",[v("li",[t._v("预渲染prerender-spa-plugin；")]),t._v(" "),v("li",[t._v("SSR服务器渲染；")]),t._v(" "),v("li",[t._v("静态化；")])]),t._v(" "),v("h3",{attrs:{id:"_31-用-vue-实现一个无限滚动的长列表-你会如何实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_31-用-vue-实现一个无限滚动的长列表-你会如何实现"}},[t._v("#")]),t._v(" 31. 用 Vue 实现一个无限滚动的长列表，你会如何实现？")]),t._v(" "),v("p",[t._v("固定的dom，对list数据进行删除和新增，下拉再加载对应数据并删除前面多余的数据。")]),t._v(" "),v("p",[t._v("坏处，没有做防抖，会出现短暂的空白。可以使用骨架屏避免。")]),t._v(" "),v("h3",{attrs:{id:"_32-vue-js-框架如何实践服务端渲染方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_32-vue-js-框架如何实践服务端渲染方案"}},[t._v("#")]),t._v(" 32. Vue.js 框架如何实践服务端渲染方案？")]),t._v(" "),v("ul",[v("li",[t._v("掌握服务端渲染（SSR）核心解决的问题")]),t._v(" "),v("li",[t._v("掌握使用 Nuxt.js 框架开发的最佳实践")]),t._v(" "),v("li",[t._v("掌握 Nuxt.js 框架使用中的 SEO 优化处理")]),t._v(" "),v("li",[t._v("掌握同构开发模式以及同构应用中的状态激活")]),t._v(" "),v("li",[t._v("了解同构类型应用的发布与自动化部署")])])])}),[],!1,null,null,null);e.default=r.exports}}]);